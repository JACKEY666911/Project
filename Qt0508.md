

# QT基础

## C++积累

设计类时是类中成员是声明，告诉编译器有这么一个东西，定义就是在内存中开辟了空间才是定义。

类对象的初始化：默认构造：无参、全缺省和编译器自动生成的。成员变量可以缺省。构造函数体里面是赋值，不是初始化。默认构造对内置类型不处理，不会被初始化，但是const修饰又必须初始化，**对自定义类型成员(`class、struct、union`)，会调用它的默认构造函数**。初始化列表才是真正的初始化。需要使用列表的：const，引用，有参构造的类。



拷贝构造函数：必须使用引用，否则无穷递归，一般形参加上const。**置类型是按照字节方式直接拷贝的，而自定义类型是调用其拷贝构造函数完成拷贝的**，编译也自动提供拷贝构造，但是是浅拷贝。

浅拷贝：类成员变量有stl的对象时，浅拷贝会引发数据覆盖问题，**析构两次会造成程序的奔溃**。

![image-20240321161127943](C:/Users/JACK/AppData/Roaming/Typora/typora-user-images/image-20240321161127943.png)





const成员函数（const写在右边，普通函数不能写右const）、对象



类成员变量是自定义类型，是指针，是STL类型



public函数不要操作私有成员变量(get 和set除外)，应该将方法设置为protected或者private。

```c++
#ifndef SENDFILE_H
#define SENDFILE_H

#include <QObject>
#include <QTcpsocket>
#include <QHostAddress>
class SendFile : public QObject
{
    Q_OBJECT
public:
    explicit SendFile(QObject *parent = nullptr);
    //连接服务器
    void connectServer(unsigned short port, QString ip);

    //发送文件
    void sendFile(QString path);

signals:
    void connectOK();
    void disconnect();
    void sendPercent(int);

private:
    QTcpSocket *m_socket;

public slots:
};

#endif // SENDFILE_H

#include "SendFile.h"

#include <QFile>
#include <QFileInfo>
#include <QMessageBox>
#include <QThread>
SendFile::SendFile(QObject *parent) : QObject(parent)
{
    m_socket = nullptr;
}

void SendFile::connectServer(unsigned short port, QString ip)
{
    qDebug() << QThread::currentThread();
    qDebug() << "111" << port << ip;
    m_socket = new QTcpSocket;
    m_socket->connectToHost(QHostAddress(ip), port);
    qDebug() << "222";
    connect(m_socket, &QTcpSocket::connected, this, &SendFile::connectOK);

    connect(m_socket, &QTcpSocket::disconnected, this, [=]()
    {
        m_socket->close();
        m_socket->deleteLater();
        emit disconnect();
    });

}

void SendFile::sendFile(QString path)
{
    if(m_socket->state() != QTcpSocket::ConnectedState)
    {
        qDebug() <<"断开";
        return;
    }
    QFile file(path);
    QFileInfo info(path);
    int fileSize = info.size();

    file.open(QFile::ReadOnly);

    while(!file.atEnd())
    {
        static int num = 0;
        if(num == 0)
        {
            m_socket->write((char*)&fileSize, 4);
        }
        QByteArray data = file.readLine();
        num += data.size();
        int percent = (num *100) / fileSize;
        emit sendPercent(percent);
        m_socket->write(data);
    }


}
```



## QT积累

0.**Qt安装和配置**

- 下载和安装Qt开发环境。

```shell
Qt 1401885521@qq.com
369258Aa
```

常用技巧：

​	Qt的构建是指使用特定的构建系统（如qmake、CMake或qbs）从Qt项目的源代码生成可执行文件或库的过程。这个过程涉及将源代码文件编译、链接，并可能包含资源文件的转换，最终生成用户可以使用的目标。



1.固定窗口尺寸，使得尺寸相适应

```c++
//固定窗口尺寸，使得尺寸相适应
setFixedSize(width(),height());
```



2.重写paintevent()后，可以通过update()手动刷新，让系统自动调用重写后的的paintevent()函数。



3.定义一个自己的控件，例如MyButton时，先看MyButton的基类，然后在ui界面找到QWidget控件，将控件升级为

mybutton显示图片，需要重写`piantevent（QPaintEvent*ev）`函数,在函数中将图片画到mybutton窗口中，然后调用update（）函数。

```c++
QPainter *p(this);
p.drawPixmap(rect(), m_pixmap);
```

![image-20240318162138472](C:/Users/JACK/AppData/Roaming/Typora/typora-user-images/image-20240318162138472.png)



`piantevent（QPaintEvent*ev）`的参数没用到时，可以删掉，改为`piantevent（QPaintEvent*）`或者`Q_UNUSED(ev)`



想在重写父类的虚函数的子类函数中继续调用父类的默认函数动作：`QWidget::QMouseEvent(ev)`;



4.命令快捷键

Qt快捷添加头文件:Alt+Enter

代码快速对齐：Ctrl + I



5.在Qt中，`geometry`是一个用于描述窗口部件（widget）位置和大小的属性。它通常是一个`QRect`对象，该对象包含了窗口部件的左上角坐标（x和y）以及其宽度和高度。

`QWidget`中包含`public`的`geometry`()方法

```c++
QRect rect = widget->geometry(); // 获取widget的当前位置和大小  
int x = rect.x();  
int y = rect.y();  
int width = rect.width();  
int height = rect.height();
```

`QWidget`的常用方法

```c++
setGeometry(int x, int y, int width, int height)：设置窗口部件的位置和大小。x和y是左上角的坐标，width和height是部件的宽度和高度。
size()：返回部件的当前大小（宽度和高度）。
pos()：返回部件的当前位置（左上角的坐标）。
move(int x, int y)：将部件移动到新的位置。x和y是新的左上角的坐标。
resize(int width, int height)：改变部件的大小。
setWindowTitle(const QString &title)：设置窗口部件的标题。
show()：显示窗口部件。如果部件之前被隐藏，这个方法会使其可见。
hide()：隐藏窗口部件。
close()：关闭窗口部件。这通常会触发一个关闭事件。
repaint()：请求立即重绘窗口部件。这通常用于当部件的内容发生变化时。
update()：安排一个更新事件来处理窗口部件的重绘。与repaint()不同，update()可能会合并多个重绘请求以优化性能。
setFixedSize(int width, int height)：设置部件的固定大小，使其不能被用户改变。
setMinimumSize(int minw, int minh) 和 setMaximumSize(int maxw, int maxh)：设置部件的最小和最大大小限制。
```



6.将int的数字转换到对应的QString，使用QString的静态方法`QString::number(int i)`



**7.QTcpSocket对象的跨线程问题：**

```c++
Widget::Widget(QWidget *parent)
    : QWidget(parent), ui(new Ui::Widget)
{
    ui->setupUi(this);

    m_pTcpSocket = new QTcpSocket();
    m_pTcpSocket->moveToThread(&m_Thread);

	//The connection type is determined when the signal is emitted. /so it's QueuedConnection
    QObject::connect(m_pTcpSocket, SIGNAL(connected()), this, SLOT(slot_connected()));
	//次线程启动
    m_Thread.start();
    //print
    qDebug() << "Main ThreadObj:" << this->thread() << "Child ThreadObj:" << &m_Thread << "TcpSocketObj:" << m_pTcpSocket;
}
//QueuedConnection //执行在主线程
void Widget::slot_connected()
{ qDebug() << QString("slot_connected ThreadID:") << QThread::currentThreadId(); }

//主线程连接按钮操作
void Widget::on_pushButton_connect_clicked()
{   m_pTcpSocket->connectToHost("127.0.0.1", 8091);  }

```



会有警告信息：不能为隶属其他线程的父对象在当前线程中创建子对象。

**`connectToHost`是在主线程中进行。**的在 connectToHost 函数的底层实现过程中，创建了一个 socketEngine 对象，它指定了 q指针(即m_pTcpSocket) 做parent 父对象。其问题在于，connectToHost 执行在主线程，因此在其执行下的 socketEngine对象属于主线程，而将 &m_pTcpSocket 这个次线程的对象指给它做父对象，这是不被 QObject 规则允许的，最终触发了QObject中的检查告警。
	原文链接：https://blog.csdn.net/quguanxin/article/details/124261689



解决：

1.将`connectToHost`函数作为槽函数，移到次线程就行。

2.套接字的相关接口只能在套接字对象所属的线程内调用（如果套接字对象没有执行过moveToThread操作，那么套接字对象的所属线程就是创建它的线程）。因此，如果想支持在次线程中执行连接/断开服务、数据收/发过程，则必须的要将套接字对象本身进行moveToThread操作，且要将其他线程对该对象的操作转换到moveToThread后的线程内。
	原文链接：https://blog.csdn.net/quguanxin/article/details/131130281



**8.有关QT线程，事件循环，信号与槽**

线程有通信套接字时和其他资源时，线程结束时应先释放套接字（`close()`掉）。

线程一般会执行while()死循环的任务，一般可以搭配标志位来使用，可以在while（）中实现槽函数的执行。

线程中是有死循环的话，线程可能退不出，可以设置线程的一个标志位m_isRunning.

```c++
while(m_isRunning)
{
    doSomething();
}

while(otherFlag)
{
    
}
```



线程是有事件循环的，`quit()`不会立即停止线程，他会等待时间循环处理完毕。`wait()`是阻塞的，只要线程已经退出。

```c++
QThread *thread = new QThread();  
// ... 启动线程并做一些工作 ...  
thread->quit(); // 请求线程退出事件循环  
thread->wait(); // 等待线程完成  
delete thread; // 删除线程对象
```





## **遇到的问题：**

1.在主函数写类，链接报错，原因是编译不会生成moc_文件，将其放到.h文件。

2.线程中QTcpSocket的问题。问题：不能为隶属其他线程的父对象在当前线程中创建子对象。注意：Qt的套接字类依赖于事件循环来处理网络事件。

3.双重容器的find如果找不到需要寻找的key值就直接调用会崩溃。

```c++
QMap<int , int> testMap；
QMap<int , QMap<int , int > doubleMap;

testMap.insert(3,3);
doubleMap.insert(1,testMap);
doubleMap.insert(2,testMap);
qDebug()<<doubleMap.find(3).value;//这一行会崩溃
//解决：用[ ]代替find( ).value即可
```



4.表格的item如果是空的调用text（）等会崩溃。解决：加判断



5.窗口一叉掉就崩溃。一般主要两个原因，第一个是存在全局对象，然后其构造函数做了什么导致的崩溃；第二个是第三方库没有配好，所以就崩了，想办法配好所有库就行。



6.定位问题：

答：打印输出/代码调试/日志记录/分析工具/找同事讨论。

（1）从二分法定位技巧可以延伸出一些具体的处理bug的方法，比如：对输入数据二分、对代码版本二分、注释掉部分代码、在不同位置插入试探性代码、对运行环境二分。

（2）可以重新读一遍程序。这种方法是最有效、最快速的 Debug 方式。

（3）



## **Qt基本概念**

**Qt对象模型**：理解Qt中对象的概念和关系，包括父子关系和**对象树**。

**就是内存管理，父亲有一个管理列表list，父亲可帮助释放内存。构造的时候就指定 parent 对象，并且大胆在堆上创建。**

析构的时候，父亲对象会在list剔除，如果有子对象，都会被一一析构。



**信号与槽机制**：了解Qt中的事件处理机制，信号和槽的连接方式。

信号槽机制有一些特点：

1. 类型安全：只有参数匹配的信号与槽才可以连接成功（信号的参数可以更多，槽会忽略多余的参数）。

2. 线程安全：通过借助QT自已的事件机制，信号槽支持跨线程并且可以保证线程安全。

3. 松耦合：信号不关心有哪些或者多少个对象与之连接；槽不关心自己连接了哪些对象的哪些信号。这些都不会影响何时发出信号或者信号如何处理。

4. 信号与槽是多对多的关系：一个信号可以连接多个槽，一个槽也可以用来接收多个信号。

   原文链接：https://blog.csdn.net/HarbinZJU/article/details/10813635



**connect(sender, signal, receiver, slot);**

1)sender：信号发送者，指针

​    2)signal：信号,函数指针

​    3)receiver：信号接收者，指针

​    4)slot：接收对象在接收到信号之后所需要调用的函数（槽函数），函数指针

 

自定义信号：声明在类的signals域下，没有返回值；只有声明没有定义；可以带参数，可以重载；通过emit关键字来触发。

自定义槽函数：声明在类的public/private/protected slots域下，没有返回值，声明得实现，可以带参数，可以重载。

**一个信号可以和多个槽函数连接，多个信号也可以和一个槽函数相连接。**

参数的话，信号的参数>=槽函数的参数，并且参数类型一致。



**connect函数的书写方式**

1.用宏＋函数原型的方式

connect(teacher, SIGNAL(hungry(QString)),student, SLOT(treat(QString)));

2.使用Lambda表达式，匿名函数对象，可以定义在某个函数体A内部。

```c++
[局部变量捕获列表]opt ->retType(参数){
    函数体
}

捕获列表可捕获A的局部变量，值传递和引用[=]/[&]或者[this]
    
 connect(btn,&QPushButton::clicked, [=](){
 QDebug()<<"Clicked";
-});
```



QMainWindow类用户主窗口

菜单栏（一个）、工具栏、状态栏、停靠部件、中心部件。

菜单栏是一个QMenu类型的对象，通过添加QAction类型的动作对象作为菜单项。QAction可放在菜单栏和工具栏中。

菜单栏:"文件(&F)"、"新增文件(&N)"、checkable可表示选中状态

QtWidgets模块：学习如何使用QtWidgets模块设计和开发图形用户界面。





## **事件机制**

掌握Qt中的事件处理机制，包括事件类型和事件过滤器。

​	



1.**事件：**可以是**用户输入、系统事件、定时器事件**等。Qt 中的每个对象都有一个事件处理函数，用于处理特定类型的事件。

Qt 事件类型：

- **键盘事件（QKeyEvent）：** 表示与键盘相关的事件，如按键按下、释放、长按等。

- **鼠标事件（QMouseEvent）：** 表示与鼠标相关的事件，如鼠标按键按下、释放、移动、双击等。

- **焦点事件（QFocusEvent）：** 表示对象获取或失去焦点的事件，如焦点进入、离开等。

- **绘图事件（QPaintEvent）：** 表示对象需要重绘的事件，如窗口移动、大小改变、部分区域曝光等。

- **定时器事件（QTimerEvent）：** 表示定时器超时的事件，用于定时器对象的触发。

- **拖放事件（QDragEnterEvent、QDragMoveEvent、QDropEvent）：** 表示拖放操作的事件，如拖动物体进入目标区域、在目标区域移动、释放拖放等。

- **输入法事件（QInputMethodEvent）：** 表示输入法相关的事件，如文本输入、候选词选择等。

- **窗口状态事件（QWindowStateChangeEvent）：** 表示窗口状态变化的事件，如最小化、最大化、恢复等。

- **布局事件（QLayoutEvent）：** 表示布局相关的事件，如布局大小改变、布局重新计算等。

- **动画事件（QAnimationEvent）：** 表示动画相关的事件，如动画开始、结束等。

- **状态切换事件（QStateChangeEvent）：** 表示状态机中状态切换的事件，如状态从一种切换到另一种等。

- **用户自定义事件（QEvent）：** 允许开发人员自定义事件类型，以满足特定应用程序的需求。

  

2.**事件处理器(Event Handler)**：事件处理器是**一个函数或方法**，用于处理特定类型的事件。在 Qt 中，事件处理器通常是 QObject 类的子类中的虚拟函数，例如 QWidget、QMainWindow 等。通过重写这些函数，可以在对象上处理相应的事件。**事件处理器可以重写。**可以重写`QPushButton`的`mousePressEvent`处理器。



3.**事件分发(Event Dispatching)：**当事件发生时，Qt 会将事件发送到适当的对象进行处理。事件分发的过程是由 Qt 的事**件循环(Event Loop)来管理**的。事件循环从应用程序的消息队列中获取事件，并将它们分发给相应的对象进行处理。



4.**事件过滤器(Event Filters)：**事件过滤器是一种机制，允许您在事件到达对象之前拦截和处理它们。通过安装事件过滤器，可以截获特定类型的事件，并在它们传递给对象的事件处理函数之前进行处理。



5.**事件循环：**Qt的事件循环是事件处理机制的核心。它负责接收、分发和处理事件，确保应用程序的响应性和交互性。









`QObject::event(QEvent *e)`和`QWidget::event(QEvent *e)`的主要区别在于它们处理的事件类型和处理的逻辑。`QObject::event(QEvent *e)`更加通用，适用于所有Qt对象，而`QWidget::event(QEvent *e)`则更加专注于处理与窗口和界面相关的事件。例如处理窗口的绘制、大小调整、移动等界面相关的事件。



```c++
bool QObject::event(QEvent *e)
{
    switch (e->type()) {
    case QEvent::Timer:
        timerEvent((QTimerEvent*)e);
        break;

    case QEvent::ChildAdded:
    case QEvent::ChildPolished:
    case QEvent::ChildRemoved:
        childEvent((QChildEvent*)e);
        break;
    // ...
    default:
        if (e->type() >= QEvent::User) {
            customEvent(e);
            break;
        }
        return false;
    }
    return true;
}

```

`event()`函数中实际是通过事件处理器来响应一个具体的事件。这相当于event()函数将具体事件的处理“委托”给具体的事件处理器。

**事件处理器是虚函数，我们重写了某一个事件处理器，即可让 Qt 调用我们自己实现的版本。**

​          

  监听全局事件：

​	**Qt** **中所有事件类都继承于QEvent。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（event handler）。**其中：event()函数主要用于事件的分发。



```c++
bool CustomTextEdit::event(QEvent *e)
{
   if (e->type() == QEvent::KeyPress) 
{
        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(e);
       if (keyEvent->key() == Qt::Key_Tab) 
{
            qDebug() << "You press tab.";
            return true;
       }
    }
    return false;
}


```

​	重写了其`event()`函数，但是没有调用父类的`event()`函数，我们只处理的`KeyPress`类型的事件，并且如果不是`KeyPress`事件，则直接返回 false，鼠标事件根本不会被转发，也就没有了鼠标事件。





监听某一类控件的事件：

​	想单独控制某一类控件的事件就只需要自定义控件然后重写从父类继承的相应的事件虚函数。`EventLabel`继承了`QLabel`，覆盖了`mousePressEvent()`、`mouseMoveEvent()`和`MouseReleaseEvent()`三个函数。

```c++
/*********.h*/
class EventLabel : public QLabel
{
protected:
    void mouseMoveEvent(QMouseEvent *event);
    void mousePressEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
};

```



监听某一个控件的事件:

​	有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，某个EditlLine可能想要拦截鼠标焦点事件，不让别的组件接收到。那么就需要使用事件过滤器（eventFilter ( QObject * watched, QEvent * event )）。

**按钮没有安装事件过滤器，事件的流程是啥样的？**

1. **事件产生**：用户点击按钮，Qt框架会产生一个`QEvent::MouseButtonPress`事件。
2. **事件分发**：Qt的事件分发系统将这个事件发送到目标对象，即按钮本身。
3. **按钮的事件处理**：按钮对象会接收到这个事件，并检查是否有自定义的槽函数（slot）或者事件处理函数（例如`mousePressEvent`）与这个事件类型相匹配。
4. **信号发射（如果适用）**：如果按钮的点击事件没有被自定义处理，按钮会按照其默认行为处理该事件，比如发射一个`clicked()`信号。
5. **事件传播**：如果按钮或其父对象没有处理这个事件，事件会继续向上传播到父对象的父对象，直到找到一个对象处理这个事件，或者事件到达顶级对象（通常是应用程序的主窗口或`QApplication`实例）。
6. **默认处理**：如果事件没有被任何对象处理，Qt会执行默认的处理逻辑，这通常意味着忽略该事件。



**按钮安装了事件过滤器，事件的流程是啥样的？**

1. **事件产生**：用户点击按钮，Qt框架会产生一个`QEvent::MouseButtonPress`事件。
2. **事件分发**：Qt的事件分发系统首先将这个事件发送到安装了事件过滤器的按钮对象。
3. **事件过滤器拦截**：在事件到达按钮对象的事件处理函数之前，它会首先被传递给事件过滤器（即之前通过`installEventFilter`安装的`QObject`子类实例）。
4. **事件过滤器处理**：事件过滤器中的`eventFilter`方法会被调用，并传入事件对象和按钮对象作为参数。在`eventFilter`方法中，开发者可以自定义处理事件的逻辑。例如，可以**检查事件的类型、修改事件参数、阻止事件继续传递**，或者执行其他任何需要的操作。
5. **决定是否继续传递事件**：根据`eventFilter`方法的返回值，Qt会决定是否继续将事件传递给按钮对象本身。如果`eventFilter`返回`true`，表示事件已被过滤器处理，并且不再继续传递给按钮；如果返回`false`，则事件会继续传递给按钮对象。
6. **按钮的事件处理**：如果事件没有被事件过滤器处理（即`eventFilter`返回`false`），事件会到达按钮对象，并按照按钮的默认事件处理机制进行。这包括检查是否有自定义的槽函数或事件处理函数（如`mousePressEvent`）与事件类型相匹配，并执行相应的逻辑。
7. **信号发射（如果适用）**：如果按钮的点击事件没有被事件过滤器拦截，并且按钮本身也没有自定义处理这个事件，按钮会按照其默认行为处理该事件，比如发射一个`clicked()`信号。
8. **事件传播（如果未被处理）**：如果按钮或其父对象没有处理这个事件，并且事件过滤器也没有返回`true`来阻止事件传播，事件会继续向上传播到父对象的父对象，直到找到一个对象处理这个事件，或者事件到达顶级对象。



**事件过滤器**：QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：

`virtual bool QObject::eventFilter ( QObject * watched, QEvent * event );`事件过滤器会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 bool 类型，不想让它继续转发，就返回 true，否则返回 false。



1. 事件过滤器可以对需要的组件接收到的事件进行过滤,以及监控
2. 任意的QObject对象都可以作为事件过滤器使用
3. 事件过滤器的实现,需要重写eventFilter()函数
4. 组件要想被监控,则需要通过installEventFilter()安装事件过滤器



<img src="C:\Users\JACK\AppData\Roaming\Typora\typora-user-images\image-20240407142921825.png" alt="image-20240407142921825" style="zoom:50%;" />



怎么做：

（1）给控件安装事件过滤器

（2）重写eventFilter函数



```c++
bool Widget::eventFilter(QObject *watched, QEvent *event)
{
    if(watched == ui->freLine)//freLine自定义Line Edit
    {
        if(event->type() == QEvent::KeyPress)
   		 {
                QKeyEvent *evt =static_cast<QKeyEvent *>(event);
                        switch (evt->key()) {
                        case Qt::Key_A:
                           //dosomething
                            return true;//不继续往父组件传递
                            break;
                        case Qt::Key_B:
                        ........
    }
    else if(watched == ui->ampLine)//ampLine自定义Line Edit
    {
       QKeyEvent *evt =static_cast<QKeyEvent *>(event);
                        switch (evt->key()) {
                        case Qt::Key_A:
                           //dosomething
                            return true;//不继续往父组件传递
                            break;
                        case Qt::Key_B:
                        ........
    }
   
    return QWidget::eventFilter(watched, event);//必要的处理其他事件
}

```



原文链接：https://blog.csdn.net/BBQ_hxl/article/details/109353263





## **Unicode、ASCII、UTF-8、base64**

他们是一种编码格式

字符数据存储都是二进制存储，需要将各个不同的字符（26、d、你）和二进制进行映射，这便是编码。

ASCII：将西文字符映射到到0-127数字之间，**字符数等于字节数**。

Unicode：将一百多万种语言的独特字符，这些字符设定好一个或者多个代码点，然后进行Encoding,

编码有多重形式：

UTF-32：将每个代码点值转为四字节的二进制数，但是使用十六禁止表示。

UTF-8:将每个代码点值转为一到四字节之间的二进制数，代码值较小的代码点映射到一字节，大 的用二到四字节。



代码点和字节区分开，不可轻易操作字符字节内容是不可靠的的。

使用unicode来访问读取字符是正确，按照字节来操作存在风险。

且不用编码格式转换可能存在乱码。



**Base64编码**

**是什么：**

是一种“二进制转换到文本”的编码方式，它能够将任意二进制数据转换为ASCII字符串的形式，以便在只支持文本协议的环境中也能够顺利地传输二进制数据。

（1）base64编码：把二进制数据转为字符；

（2）base64解码：把字符转为二进制数据；

**为什么：**

因为有些网络传输渠道并不支持所有字节，例如传统的邮件只支持可见字符的传输，像ASCII码的控制字符（ASCII码包含了 128 个字符。其中前 32 个， 0-31 ，即 0x00-0x1F ，都是不可见字符。这些字符，就叫做控制字符。）就不能通过邮件传输。另外，例如图片二进制流的每个字节不可能全部都是可见字符，所以就传送不了。

  最好的方法就是在不改变传统协议的情况下，做一种扩展方案来支持二进制文件的传送，把不可能打印的字符用可打印的字符标识，问题就解决了。Base64编码就应运而生，Base64就是一种基于64个可打印字符来表示二进制数据的表示方法。



**怎么做：**

![img](https://ask.qcloudimg.com/http-save/yehe-8913398/dcc97d88b04fc0fdbac052d777151c09.png)





编码过程：先将字符转换为二进制，然后每6位为一个单元，进行十进制的转换，然后对照上面的编码表进行编码，最终编码产物要是4的倍数，不够用=补齐。

**使用场景：**

Base64可以把任意的二进制数据转换成可打印的ASCII码，可用于电子邮件、URL参数传输、（图像、视频等）数据传输、图像数据嵌入。





## Qt的数据类型

`QByteArray` 是 Qt 框架中用于处理字节数组的类。它允许你存储和操作原始字节数据，这在处理网络数据、读取或写入文件、以及与其他系统或库交互时非常有用。



`QString`：用于存储和操作Unicode字符串。

**整数类型**：Qt提供了不同大小的整数类型，如`bool`、`char`、`short`、`int`、`long`以及特定于Qt的`qint8`、`qint16`、`qint32`和`qint64`。其中，`qint`表示有符号整数。

**容器类型**

- `QList`：用于存储一组对象的动态数组。
- `QVector`：同样用于存储一组对象的动态数组，但与`QList`相比，它在内部使用连续的内存空间，因此在某些情况下可能具有更好的性能。
- `QMap`：用于存储一组键值对的关联数组。
- `QHash`：提供了基于哈希的键值对存储，适用于需要快速查找的情况。
- `QSet`：是一个存储唯一元素的集合。

**其他类型**

- `QPoint`、`QSize`、`QRect`等用于处理几何数据。
- `QColor`、`QImage`、`QPixmap`等用于处理颜色和图像数据。
- `QUrl`：用于表示和操作URL。
- `QVariant`：是一个可以存储各种数据类型的通用类，常用于模型/视图编程和设置/获取对象属性。



## Qt控件

Qt基础控件：

**QWidget：**所有可视化控件的基类

**QMainwindow：**主窗口类，通常作为应用程序的主窗口使用，可以包含菜单栏、工具栏、状态栏等组件。

**QDialog：**对话框窗口的基类



**按钮：**

QPushButton：按钮。

QToolButton:常用作工具栏的快捷工具，能够插入默认的**action**、**menu**，同时也能设置**图标和文字**。

**显示：**

**QLabel：** 标签控件，用于显示文本或**图像**或者动画。

**QTextBrowser**：文本浏览器控件，用于显示和编辑富文本。



**Item Views:**

在Qt中使用[model](https://so.csdn.net/so/search?q=model&spm=1001.2101.3001.7020)/View结构来管理数据与视图的关系，model负责数据的存取，数据的交互则通过[delegate](https://so.csdn.net/so/search?q=delegate&spm=1001.2101.3001.7020)来实现。



![img](https://img-blog.csdnimg.cn/img_convert/dd7d9b8bf67cc9afed7063f3f257d423.png)

源数据由模型 (Model) 读取，然后在视图 (View) 组件上显示和编辑，在界面上编辑修改的数据又通过模型保存到源数据。



Data：原始数据，数据库的 一个数据表、内存的一个字符串列表或者磁盘文件

Model：与元数据通信，并为视图组件提供数据接口，从源数据提取数据，用于视图组件显示和编辑

View：界面控件。

Delegate：在视图和模型间交互操作是提供临时编辑组件的功能。



通信：

源数据发生变化，Model发送信号通知视图组件

用户在界面操作数据时，视图组件发射信号表示这些操作信息

在编辑数据时，代理会发射信号告知数据模型和视图组件编辑器的状态。



**Qt 的Model类：model中存放的每项数据都有相应的"model index"，由QModelIndex类来表示。每个index由三个部分构成：row，column和表明所属model的指针。对于一维的list model，column部分永远为0。**

![img](https://img-blog.csdnimg.cn/img_convert/999fbab2406d2091c45bd1ec4b350ec0.png)



**QFileSystemModel 类**：为本机的文件系统提供一个数据模型，可用于访问本机的文件系统。

**QStringListModel类：**用于处理字符串列表的数据模型，可以作为QListView的数据模型，在界面上显示和编辑字符串列表。

**QStandardItemModel类：**以项数据（item data）为基础的标准数据结构模型类，通常与QTableView配合使用，实现通用的二维数据的管理。





![img](https://img-blog.csdnimg.cn/img_convert/b432e0e7f3173e0c9e113779d2de2a66.png)

**Qt view 类**



![View类的继承关系](https://img-blog.csdnimg.cn/img_convert/49ef9dcaf79bc532af0c22da32c4ec11.png)



**QListView：**用于显示单列的列表数据，适用于一维数据的操作
**QTreeView：**用于显示树状结构数据，适用于树状结构数据的操作
**QTableView：**用于显示表格状数据，适用于二维表格型数据的操作
**QColumnView：**用多个QListView显示树状层次结构，树状结构的一层用一个QListView显示
**QHeaderView：**提供行表头或列表头的视图组件，如QTableView的行表头和列表头





`QStandardItem`、`QStandardItemModel`和`QTableView`三个类协同工作，用于构建和展示表格数据。

```c++
#include <QApplication>  
#include <QTableView>  
#include <QStandardItemModel>  
#include <QStandardItem>  
  
int main(int argc, char *argv[])  
{  
    QApplication app(argc, argv);  
  
    // 创建一个QStandardItemModel对象  
    QStandardItemModel *model = new QStandardItemModel(4, 3); // 4行3列  
  
    // 设置模型的表头  
    QStringList headers;  
    headers << "列1" << "列2" << "列3";  
    model->setHorizontalHeaderLabels(headers);  
  
    // 填充数据  
    for (int row = 0; row < 4; ++row) {  
        for (int column = 0; column < 3; ++column) {  
            QStandardItem *item = new QStandardItem(QString("Item %1-%2").arg(row+1).arg(column+1));  
            model->setItem(row, column, item);  
        }  
    }  
  
    // 创建一个QTableView对象  
    QTableView *view = new QTableView;  
    view->setModel(model); // 将模型设置为视图的数据源  
    view->show(); // 显示视图  
  
    return app.exec();  
}
```





`QStringListModel`和`QComboBox`/`QListView`的协同使用

```c++
#include <QApplication>  
#include <QWidget>  
#include <QVBoxLayout>  
#include <QListView>  
#include <QStringListModel>  
  
int main(int argc, char *argv[])  
{  
    QApplication app(argc, argv);  
  
    // 创建一个包含字符串的列表  
    QStringList stringList;  
    stringList << "Apple" << "Banana" << "Cherry" << "Date" << "Elderberry";  
  
    // 创建一个 QStringListModel 对象，并将字符串列表传递给它  
    QStringListModel *model = new QStringListModel(stringList);  
  
    // 创建一个 QWidget 作为主窗口  
    QWidget window;  
    QVBoxLayout *layout = new QVBoxLayout(&window);  
  
    // 创建一个 QListView 对象  
    QListView *listView = new QListView;  
    listView->setModel(model); // 将模型设置为视图的数据源  
  
    // 将 QListView 添加到布局中  
    layout->addWidget(listView);  
  
    // 设置窗口的其他属性（可选）  
    window.setWindowTitle("QStringListModel Example");  
  
    // 显示窗口  
    window.show();  
  
    return app.exec();  
}

//#############################################################################################
#include <QApplication>  
#include <QWidget>  
#include <QVBoxLayout>  
#include <QComboBox>  
#include <QStringListModel>  
  
int main(int argc, char *argv[])  
{  
    QApplication app(argc, argv);  
  
    // 创建一个包含字符串的列表  
    QStringList stringList;  
    stringList << "Option 1" << "Option 2" << "Option 3" << "Option 4";  
  
    // 创建一个 QWidget 作为主窗口  
    QWidget window;  
    QVBoxLayout *layout = new QVBoxLayout(&window);  
  
    // 创建一个 QComboBox 对象  
    QComboBox *comboBox = new QComboBox;  
  
    // 创建一个 QStringListModel 对象，并将字符串列表传递给它  
    QStringListModel *model = new QStringListModel(stringList);  
  
    // 将模型设置为 QComboBox 的数据源  
    comboBox->setModel(model);  
  
    // 设置下拉框的显示文本角色（可选，通常用于自定义显示）  
    comboBox->setModelColumn(0); // 通常使用第0列，除非你的模型有多列数据  
  
    // 将 QComboBox 添加到布局中  
    layout->addWidget(comboBox);  
  
    // 设置窗口的其他属性（可选）  
    window.setWindowTitle("QComboBox and QStringListModel Example");  
  
    // 显示窗口  
    window.show();  
  
    return app.exec();  
}

```

 



**item Widgets**

QListView
        1.QListView继承于QAbstractItemView。
        2.QListView提供数据模型和视图分开的操作方法。
            QListView仅仅封装了数据模型(QStandardItemModel)的基本操作功能。并不包含数据模型本身(QStandardItemModel)。
        3.QListView中如果需要操作数据模型, 需要先调用统一的接口来给自己设置一个数据模型。
          毕竟没有数据模型, 视图去操作什么呢?
            // QListView.setModel(QStandardItemModel *model);
        4.QListView支持为模型(QStandardItemModel)中的某一个QStandardItem对象添加一个窗口对象索引,
            这样就可以在某个item上显示一个窗口, 这使得继承他的子类QListWidget也具有该功能。



 QListWidget
        1.QListWidget将视图和模型柔和在一起，使用户在item上显示窗口的操作更加简单。但是他的功能就被局限于在item上显示窗口。
        2.分析源码：看QListWidget是如何同时封装视图和数据模型二者的。
            1.首先QListWidget继承于QListView，这就提供了视图的操作功能。
            2.增加一个item是QListWidgetItem对象
            3.QListWidget继承于QListView,也支持(将一个窗口设置为某个item的索引窗口)的方法setIndexWidget(const QModelIndex &, QWidget *)
               



**input Widgets：接受用户输入的控件**

QTextEdit：是一个多行文本编辑框，支持更复杂的文本编辑，如富文本格式、撤销/重做等。

QSpinBox和 QDoubleSpinBox：分别用于输入整数和浮点数。它们提供了一个可以上下滚动的界面，方便用户快速选择数值。

QComBox：`QComboBox` 是一个下拉选择框，允许用户从预定义的选项列表中选择一个值。它可以与 `QStringListModel` 结合使用，以动态管理选项列表。

QTimeEdit：编辑选择时间

QDateEdit：编辑选择时间

QDate/Time Edit：日期和时间



**容器：**

**QGroupBox**：分组框，用于将多个控件组合在一起，并带有标题。

**QScrollArea**：滚动区域，用于在界面上展示超出可视范围的内容。

**Tab Widget：**实现选项卡式的界面设计。它允许用户通过点击不同的选项卡来轻松地在多个页面之间切换。



**对话框：**

**消息对话框QMessageBox：**用于显示简短消息或询问用户问题的对话框。它们通常用于向用户显示通知、警告或错误，或要求用户做出决策。

**标准对话框：**标准对话框是Qt预定义的、具有通用功能的对话框类。

- **文件对话框** (`QFileDialog`)：用于打开和保存文件。
- **颜色对话框** (`QColorDialog`)：用于选择颜色。
- **字体对话框** (`QFontDialog`)：用于选择字体。
- **打印对话框** (`QPrintDialog`)：用于配置打印设置。

**自定义对话框**：创建自定义对话框通常涉及继承 `QDialog` 类或其他相关类，并在其中添加所需的控件和逻辑。



## Qt多线程编程



**所有的GUI类（如QWidget及其子类），操作系统核心类（如QProcess）和网络类都不是线程安全的。**



程序最小的执行单位

线程的创建比进程开销小，速度快。

同一进程内的线程切换快，尤其用户级别的

线程对c/s模型很有效

进程有独立的地址空间，线程贡献地址空间和资源



**场景：**

某些任务比较耗时

应用程序各种任务相对独立

实时系统应用

个任务有不同的优先级；



### **线程和事件循环**

​	线程是用于执行代码的执行上下文。主线程通常负责执行主要代码逻辑、**处理用户交互和更新UI**。额外的线程则用于处理耗时操作，如**网络请求、定时器事件**等，以避免阻塞主线程。这些线程在后台运行，并通过事件循环与主线程进行通信。

​	**注意：**主线程是GUI线程。其他的线程内不能执行GUI相关的工作，也不要存在GUI相关的类，可以使用`QTimer`、`QTcpSocket、QProcess`。

​	事件循环则是实现异步操作的机制。它**持续监听事件队列**，并将事件分发到适当的线程进行处理。当一个异步操作完成时，它会生成一个事件，将其放入事件队列中，等待主线程或其他线程处理。主线程空闲时，会从事件队列中取出事件，并执行相应的回调函数。



如果线程没有事件循环，或者线程中的某些代码阻塞了事件循环，则`QThread::quit`不会执行任何操作。所以它不一定会停止线程。

所以`QThread::quit`告诉线程的事件循环退出。在调用它之后，一旦控制返回到线程的事件循环，线程就会结束。

如果阻塞事件循环，则必须添加某种中止标志，例如，通过在循环中工作。这可以通过一个布尔成员变量来完成，该成员变量是公共的，或者至少有一个公共的setter方法。然后，您可以通过设置中止标志来告诉线程尽快从外部退出(例如，从主线程退出)。当然，这需要您的线程代码定期检查中止标志。





### **可重入和线程安全**

可重入：可重入性主要关注于函数或代码段在多次执行或被多个执行流调用时，其结果的一致性。**一个可重入的函数不能为后续的调用保持静态（或全局）数据，也不能返回指向静态（或全局）数据的指针。**

线程安全：如果没有造成资源的冲突，也没有产生错误的结果。

可重入强调并发执行时结果的一致性，而线程安全考虑的是代码的正确执行。



不可重入的类，类中有`static `成员变量，属于类级别的，所有实例共享。

```c++
class NonReentrantClass {  
private:  
    static int staticState; // 静态变量，所有实例共享  
  
public:  
    NonReentrantClass() {}  
  
    // 这个方法改变了静态状态，因此是不可重入的  
    void changeState() {  
        staticState++; // 修改静态变量的值  
    }  
  
    // 这个方法返回静态状态的值  
    int getState() const {  
        return staticState;  
    }  
  
    // 静态变量的初始化  
    static int initializeStaticState() {  
        static bool isInitialized = false;  
        if (!isInitialized) {  
            staticState = 0;  
            isInitialized = true;  
        }  
        return staticState;  
    }  
};  
  
// 静态成员变量的定义和初始化  
int NonReentrantClass::staticState = NonReentrantClass::initializeStaticState();
```



可重入按时线程不安全的类：在单线程环境中，你可以多次调用`increment()`方法，每次都会安全地增加计数器的值。然而，在多线程环境中，如果两个线程同时调用`increment()`方法，它们可能会同时读取`count`的当前值，各自增加1，然后再写回。

```c++
class Counter {  
private:  
    int count;  
  
public:  
    Counter() : count(0) {}  
  
    // 这个方法是可重入的，因为它不依赖于之前的调用状态  
    void increment() {  
        count++;  
    }  
  
    int getCount() const {  
        return count;  
    }  
};
```



修改

```c++
class Counter {  
private:
    int conut;
    QMutex mutex;
public:
    Counter():count(0){}
    
    void increment()
    {
        QMutexLocker locker(&mutex);
        count++;
    }
    
    int getCount() const
    {
        QMutexLocker locker(&mutex);
        return count;
    }   
};
```



### **核心线程类**

1. **QThread**：这是 Qt 中多线程编程的核心类。它表示一个线程，并允许你控制线程的启动、停止和管理。
2. **QThreadPool**：这个类提供了一个线程池，用于管理一组 QThread 对象。它可以帮助你优化线程的使用，避免频繁地创建和销毁线程。

`QThread`常用公共成员函数

```c++
//判断线程中的任务是否执行完毕
bool isFinished() const
//判断子线程是否在执行任务    
bool isRunning() const

//得到当前线程的优先级    
Priority priority() const

void setPriority(Priority priority)
 
//退出线程，停止底层的事件循环
void exit(int returnCode = 0)

//调用线程退出函数后，县城不会马上退出，因为当前任务可能还没完成，接着调用wait函数，然后退出线程   
bool wait(unsigned long time = ULONG_MAX)


```

`QThread`的信号与槽

```c++
//线程中任务完成时发出该信号
void finished()
//开始工作之前发出该信号，用得少 
void started()
    
//槽函数
void QThread::quit();

void start(Priority priority = InheritPriority)

```



静态函数

```c++

QThread *currentThread();

QThread *currentThread()
void msleep(unsigned long msecs)
void sleep(unsigned long secs)
void usleep(unsigned long usecs)

```



任务函数

```c++
//需要重写，内部为任务操作
virtual void run()

```



**线程间通信**

1. **信号与槽（Signals and Slots）**：Qt 的信号与槽机制是实现线程间通信的主要方式。通过连接不同线程中对象的信号和槽，你可以安全地在线程之间传递消息和数据。



**线程安全的数据结构和类**

1. **QMutex**：互斥锁，用于保护共享资源，防止多个线程同时访问。
2. **QReadWriteLock**：读写锁，允许多个线程同时读取共享资源，但写操作是互斥的。
3. **QSemaphore**：信号量，用于控制对有限资源的访问。
4. **QWaitCondition**：等待条件，通常与互斥锁一起使用，允许线程在满足特定条件之前等待。



**其他相关类**

1. **QRunnable**：这是一个抽象类，定义了要在线程中运行的任务。你可以创建自己的 QRunnable 子类来定义特定的任务，并将其提交给 QThreadPool 执行。
2. **QFuture 和 QFutureWatcher**：这些类提供了异步编程的接口。QFuture 表示一个异步计算的结果，而 QFutureWatcher 可以用来监视 QFuture 的状态变化。
3. **QConcurrent**：这个命名空间提供了一组高级函数，用于在 Qt 中进行简单的并行计算。它使用 QThreadPool 来管理线程，并简化了多线程编程的复杂性。





**线程池类：`QThreadPool`**



线程池分类
使用线程池时通常我们可以将执行的任务分为两类：

cpu 密集型任务
io 密集型任务
cpu 密集型任务，需要线程长时间进行的复杂的运算，这种类型的任务需要少创建线程（以CPU核数+1为准），过多的线程将会频繁引起上文切换，降低任务处理速度

而 io 密集型任务，由于线程并不是一直在运行，可能大部分时间在等待 IO 读取/写入数据，增加线程数量可以提高并发度，尽可能多处理任务
原文链接：https://blog.csdn.net/qq_34486648/article/details/124294345





池资源，线程池管理一组`QThread`对象，主要是减少创建销毁线程池的开销。

1.Qt程序都有一个全局的线程池对象，通过这个函数访问

```c++

QThreadPool *globalInstance()
    
// 获取全局线程池  
QThreadPool *threadPool = QThreadPool::globalInstance();  
```



2.任务类继承`public QRunnable`，在这个类中，实现 `run()` 虚函数。这个函数中的代码将在线程池中的某个线程上执行。



```c++

  class HelloWorldTask : public QRunnable
  {
      void run()
      {
          qDebug() << "Hello world from thread" << QThread::currentThread();
      }
  }


```



3.创建任务类对象，**将 `QRunnable` 对象传递给 `QThreadPool`**，使用 `QThreadPool` 的 `start()` 方法来开始执行你的 `QRunnable` 对象。

```c++
  HelloWorldTask *hello = new HelloWorldTask();
  // QThreadPool takes ownership and deletes 'hello' automatically
  QThreadPool::globalInstance()->start(hello);
```



4.等待线程池中的所有任务完成  

```c++
 threadPool->waitForDone();  
```





### Qt中实现多线程

线程创建使用一：

1.创建子类继承QThread

2.重写父类的`run()`方法，在内部编写子线程要处理的具体业务流程

3.在主线程创建子线程对象

4.启动子线程，调用`start()`方法



线程创建使用二：

1.创建一个Work类继承QObject类，在类中添加公有函数体，实现业务逻辑

2.在子线程中创建`QThread`对象

3.在主线程中创建工作类的对象，千万不要指定父对象，不然无法移动到子线程对象

4.将MyWork对象移动到子线程对象中，调用`QThread`的`moveToThread()`方法

5.启动子线程，调用`satrt()`方法，但是移动到子线程的对象并没有工作

6.调用`MyWork()`方法。让这个函数开始执行。









## Qt的网络通信

### 1.TCP



Qt提供了基于套接字通信的类，属于network模块

QTcpServer:服务器类，用于监听客户端连接和与客户端简历连接

QTcpSocket：通信类的套接字,客户端、服务器都需要使用



服务器创建使用

1.集成QTcpServer类，创建对象。

2.监听和绑定，调用listen(QHostAddress::Any, port)

3.有客户端连接时，发自动发送newConnect()信号，利用信号与槽`connect()`，调用nextPendingConnection(),得到用于通信的套接字：`QTcpSocket*`



**Qt写一个基于多线程的Tcp服务器程序**

```c++
#include <QtWidgets>
#include <QtNetwork>

class TcpServer : public QTcpServer {
    Q_OBJECT

public:
    TcpServer(QObject *parent = nullptr) : QTcpServer(parent) {}

protected:
    void incomingConnection(qintptr socketDescriptor) override {
        TcpClientThread *clientThread = new TcpClientThread(socketDescriptor, this);
        connect(clientThread, &TcpClientThread::finished, clientThread, &TcpClientThread::deleteLater);
        clientThread->start();
    }
};

class TcpClientThread : public QThread {
    Q_OBJECT

public:
    TcpClientThread(qintptr socketDescriptor, QObject *parent = nullptr) : QThread(parent), socketDescriptor(socketDescriptor) {}

    void run() override {
        QTcpSocket socket;
        if (!socket.setSocketDescriptor(socketDescriptor)) {
            emit error(socket.error());
            return;
        }

        connect(&socket, &QTcpSocket::readyRead, this, &TcpClientThread::readyRead);
        connect(&socket, &QTcpSocket::disconnected, this, &TcpClientThread::disconnected);

        exec();
    }

signals:
    void error(QTcpSocket::SocketError socketError);

private slots:
    void readyRead() {
        QTcpSocket *socket = static_cast<QTcpSocket *>(sender());
        while (socket->bytesAvailable() > 0) {
            QByteArray data = socket->readAll();
            // 在这里处理收到的数据，可以在控制台打印或者向客户端发送响应等操作
            qDebug() << "Received: " << data;
        }
    }

    void disconnected() {
        QTcpSocket *socket = static_cast<QTcpSocket *>(sender());
        socket->deleteLater();
        exit(0);
    }

private:
    qintptr socketDescriptor;
};

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    TcpServer server;
    if (!server.listen(QHostAddress::Any, 1234)) {
        qDebug() << "Server could not start!";
        return 1;
    } else {
        qDebug() << "Server started!";
    }

    return app.exec();
}

#include "main.moc"

```



QTcpSocket类可以server和client使用，收发数据属于I/O操作。

![image-20240319141153871](C:/Users/JACK/AppData/Roaming/Typora/typora-user-images/image-20240319141153871.png)



QTcpSocket

```c++

```

QAbstractSocket

```c++
signal
    connected();//调用connectToHost()成功后emit该信号，在客户端使用该信号
	disconnectd();//服务器断开连接，客户端信号就会发送

//公有方法
//客户端与服务器进行连接
virtual void 
connectToHost(const QString &hostName, quint16 port, OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol)
    
virtual void 
connectToHost(const QHostAddress &address, quint16 port, OpenMode openMode = ReadWrite)


```



QIODevice

```c++
//读取数据
QByteArray read(qint64 maxSize);
qint64 read(char *data, qint64 maxSize);
QByteArray readAll()

//写入数据
qint64 write(const char *data);//c风格
qint64 write(const QByteArray &byteArray)//

signal
void readyRead()//信号：说明对端发送的数据已经到达了，可以调用read()方法了

```



客户端创建使用

1.创建用于通信的QTcpSocket对象

2.连接服务器，绑定服务器的IP和端口，使用的是QAbstractSocket的connectToHost()方法

3.使用QTcpSocket对象与服务器进行通信



### 2.UDP





### 3.HTTP







## Qt文件操作

1.Qt进行文件的读取和写入操作

2.文件和目录操作

Qt文件相关的类：

**QFile**：

- 用于文件的读取和写入。
- 提供了打开、关闭、读取、写入和定位文件指针等功能。

**QTextStream**：

- 提供了方便的文本输入/输出流接口，可以与QFile结合使用，用于文本文件的读写。
- 支持格式化输出和简单的文本解析。

**QDataStream**：

- 用于读写二进制数据，可以处理Qt的数据类型，如QString、QImage等。
- 提供了紧凑的二进制格式，用于存储和加载Qt对象。

**QDir**：

- 用于目录操作，如创建目录、删除目录、列出目录内容等。
- 提供了对文件路径的解析和构建功能。

**QFileInfo**：

- 提供了关于文件的信息，如文件名、文件大小、创建时间等。
- 可以从QDir或QFile对象中获取QFileInfo对象。

**QFileSystemWatcher**：

- 用于监控文件和目录的更改，如文件被创建、修改或删除。
- 可以在文件或目录发生变化时发出信号。

**QFileDialog**：

- 提供了标准的文件对话框，用于打开文件、保存文件以及选择目录。
- 支持文件过滤和自定义对话框选项。

**QBuffer**：

- 是一个在内存中存储数据的设备，可以作为QFile的替代品，用于在内存中读写数据。

**QStorageInfo**：

- 提供了关于存储设备的信息，如硬盘空间、文件系统类型等。
- 可以用于获取和管理存储设备的详细信息。



## **Qt的数据库操作**

数据库是C-S架构的，连接的数据库属于服务器端，Qt的应用程序是客户端。

```c++
QT += core gui sql
```

`mysql`根节点用户是`root`，在用户下可以添加很多个数据库，每个数据库下有多个数据表。

这个sql模块对应的是一个动态库，mysql提供给Qt的是源码，需要自己编译成动态库。

Qt数据库的编译：

1.操作系统版本

2.数据库版本不一样

3.Qt版本不一样（4、5（5.12、5.14）、6）、Qt编译套件（MingW、MSVC）（32位和64位）

4.编译Qt数据库驱动的时候需要数据库提供的动态库（libmysql.dll）、编译套件的位数要和数据库的位数保持一致

5.开始编译，得到动态库

6.将动态库部署到合适的位置





Qt需要mysql的驱动插件，才能和mysql进行连接沟通

Qt编译mysql驱动流程

1.下载64位的mysql安装，然后记录bin的路径，路径不要有空格

2.安装Qt，带源码，然后找到`E:/Qt/6.5.3/Src/qtbase/src/plugins/sqldrivers`这个路径，编辑.cmake.conf，添加下面的配置

```shell
SET(FEATURE_sql_mysql ON)
SET(MySQL_INCLUDE_DIR "D:/mysql/mysql-8.0.36-winx64/include")
SET(MySQL_LIBRARY "D:/mysql/mysql-8.0.36-winx64/lib/libmysql.lib")
```



3.然后用qt打开CMakeLists.txt，选择MinGW-64位和MSVC编译器套件。各自编译debug版本和release版本。

4.然后进入E:\Qt\6.5.3\Src\qtbase\src\plugins，扎到对应的文件，参考sqlite的文件放到E:\Qt\6.5.3\mingw_64\plugins\sqldrivers和E:\Qt\6.5.3\msvc2019_64\plugins\sqldrivers当中![image-20240323140629397](C:\Users\JACK\AppData\Roaming\Typora\typora-user-images\image-20240323140629397.png)



5.将mysql的libmysql.dll放入到E:\Qt\6.5.3\msvc2019_64\bin和E:\Qt\6.5.3\mingw_64\bin中

6.在QT编写程序测试

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QSqlDatabase>
#include <QSqlError>
#include <QDebug>
#include <QMessageBox>

#include<QSqlQuery>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QStringList list = QSqlDatabase::drivers();
    qDebug() << list;
    QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL");
    if(db.isValid())
    {
        db.setHostName("localhost");
        db.setPort(3306);
        db.setUserName("root");
        db.setPassword("369258");
        db.setDatabaseName("testdb");

        if(db.open())
        {
            QSqlQuery query;
            QString sql = "select * from students";
            query.exec(sql);
            while(query.next())
            {
                qDebug() << query.value(0).toUInt()
                    << query.value(1).toString()
                    << query.value(2).toInt()
                    << query.value(3).toString();
            }
        }

    }
    else
    {
        qDebug()<<"error";
    }

}

MainWindow::~MainWindow()
{
    delete ui;
}
```



数据库QT编程：

1.QT连接数据库

2.QT数据库的查询操作,主要使用`QSqlQuery`类

3.QT的数据库事务操作：

​	对数据的一种保护，保持对数据的一种原子性操作（对数据项的一系列操作，这些操作要么全部执行，要么全部不执行），事务由**事务开始与事务结束之间执行的全部数据库操作组成**。

**数据库事务处理流程一般包括以下步骤：**

1. 开始事务：事务处理的第一步是开始一个事务。这需要应用程序发送一个BEGIN或START TRANSACTION语句给数据库管理系统。
2. 执行SQL操作：一旦事务开始，应用程序可以执行各种SQL操作，如插入、更新和删除数据等。
3. 提交或回滚事务：执行完所有的SQL操作后，应用程序需要决定是提交事务还是回滚事务。
4. 持久化数据：如果应用程序选择提交事务，数据库管理系统将完成所有的操作，将数据永久保存到数据库中。



怎么做：在update或者insert操作失败时，可回滚。

```c++
//创建事务
bool QSqlDatabase::transaction
//提交事务
bool QSqlDatabase::commmit
//回滚事务
bool QSqlDatabase::rollback;
```





```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QSqlDatabase>
#include <QSqlError>
#include <QDebug>
#include <QMessageBox>

#include<QSqlQuery>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QStringList list = QSqlDatabase::drivers();
    qDebug() << list;
    QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL");
    if(db.isValid())
    {
        db.setHostName("localhost");
        db.setPort(3306);
        db.setUserName("root");
        db.setPassword("369258");
        db.setDatabaseName("testdb");

        if(db.open())
        {
            QSqlQuery query;
            QString sql = "select * from students";
            bool flag = query.exec(sql);
            if(!flag)
            {
                qDebug() << "exec failed!";
            }
            while(query.next())
            {
                qDebug() << query.value(0).toUInt()
                    << query.value(1).toString()
                    << query.value(2).toInt()
                    << query.value(3).toString();
            }
            sql = "insert into students values(8, '爱思', 30, '2024-03-23')";
            
			//创建一个事务
            db.transaction();
            flag = query.exec(sql);
            if(flag)
            {
                //提交事务
                db.commit();
            }
            else
            {
                //回滚事务
                db.rollback();
            }

        }

    }
    else
    {
        qDebug()<<"error";
    }

}
```









Qt有关数据库的类

`QSqlDatabase`：

​	用于处理与数据库的连接。它提供了一个接口，通过该接口可以访问连接到的数据库。

​	调用`QSqlDatabase::addDatabase("QPSQL")`创建了一个到PostgreSQL数据库的默认连接。然后设置数据库的主机名、数据库名、用户名和密码。最后尝试打开连接。

```c++
#include <QSqlDatabase>  
#include <QSqlError>  
#include <QDebug>  
  
int main() {  
    // 创建一个到PostgreSQL数据库的默认连接  
    QSqlDatabase db = QSqlDatabase::addDatabase("QPSQL");  //数据库的驱动名，不同的数据库对应的不同的驱动名。
    //可以通过drivers方法获取支持的驱动名
	QStringList list = QSqlDatabase::drivers();
      
    // 设置数据库连接参数  
    db.setHostName("localhost"); // 数据库服务器地址  
    db.setDatabaseName("mydatabase"); // 数据库名称  
    db.setUserName("myusername"); // 数据库用户名  
    db.setPassword("mypassword"); // 数据库密码  
      
    // 尝试打开数据库连接  
    if (!db.open()) {  
        // 打开失败，输出错误信息  
        qDebug() << "Error:" << db.lastError().text();  
        return -1;  
    }  
      
    // 连接成功，可以继续执行数据库操作...  
      
    // 在结束程序前关闭连接  
    db.close();  
      
    return 0;  
}
```



`QSqlQuery` 类：

​	提供了执行和操作 SQL 语句的手段。

​	数据操纵语言 (DML) 语句： SELECT、INSERT、UPDATE 和 DELETE。

​	数据定义语言 (DDL) 语句：CREATE TABLE

```c++
QSqlQuery query;
QString sql = "select * from table";
bool flag = query.exec(sql);//执行sql语句，查询数据，执行成功返回true

//如果是查询，会将结果保存到query的结果集，结果集中包含的是多行多列的数据，一行一行的遍历。
while(query.next())
{
                qDebug() << query.value(0).toUInt()
                    << query.value(1).toString()
                    << query.value(2).toInt()
                    << query.value(3).toString();
}
```





`QSqlQueryModel`类：

​	数据库模型类，适用在model/view框架中。**`QSqlQueryModel` 类为 SQL 结果集提供了一个只读的数据模型。它是执行 SQL 语句和遍历结果集的高级接口，建立在底层的 `QSqlQuery` 之上，并可用于为视图类（如 `QTableView`）提供数据。**

model与view分离，很大的灵活性和可重用性。

model：模型是数据的容器，它负责管理数据**，注意它不直接存储数据。**它是类似一个桥梁，连接数据源和视图，它从数据源获取数据，并转换格式，然后提供给视图；模型通过信号和槽机制通知视图数据的变化；视图修改数据时，model收到修改操作，并同步回数据源。

view：视图负责数据的展示。Qt 提供了几种内置的视图类。视图与模型通过接口进行通信，它们并不知道模型内部的具体实现细节。视图只关心如何从模型中获取数据以及如何展示这些数据。



`QSqlError`类：数据库操作失败时可通过这个类提供相关的错误信息。



- **C++基础**：

  - 类和对象：熟悉类和对象的概念，以及如何定义和使用它们。
  - 继承和多态：理解继承和多态的概念，以及它们在Qt中的应用。
  - 指针和引用：掌握指针和引用的概念，以及它们在Qt中的使用。

- **Qt核心模块**：

  - QtCore模块：了解QtCore模块提供的核心功能，如数据类型、容器、线程等。
  - QtGui模块：熟悉QtGui模块提供的图形用户界面组件和功能。

- **Qt编程基础**：

   - 控件和布局：掌握常见控件的使用和布局管理器（如QVBoxLayout、QHBoxLayout）的应用。
   - 对话框和消息框：了解如何使用Qt提供的对话框和消息框组件与用户进行交互。
   - 绘图和绘图设备上下文：熟悉Qt中的绘图功能和绘图设备上下文的使用。

- **Qt事件处理**：

   - 事件类型和事件处理器：理解Qt中的事件类型，以及如何通过事件处理器来处理这些事件。
   - 自定义事件：学习如何定义和处理自定义事件。

- **Qt文件操作**：

   - 文件读写操作：了解如何使用Qt进行文件的读取和写入操作。
   - 文件和目录操作：掌握Qt提供的文件和目录操作相关的类和函数。

- **Qt网络编程**：

   - 基于套接字的网络编程：学习如何使用Qt进行基于套接字的网络通信。
   - HTTP请求和响应：了解如何使用Qt进行HTTP请求和响应。

- **Qt数据库编程**：

   - 数据库连接和操作：掌握如何使用Qt进行数据库的连接和基本操作。
   - SQL查询和模型视图编程：了解如何使用Qt进行SQL查询和模型视图编程。

   



# QML学习

QML是一种声明式语言，利用可视化组件，进行交互和关联来描述用户界面。也可以连接C++后端。

QML是一种声明式语言，解释型语言。类似 JSON 的语法。

Qt Quick 是 QML 类型和功能的标准库。

QML/Qt Quick 和 Node.js 类似，也提供了一系列 JS 和 C++ 交互的接口，便于 JS 和 C++ 通信。



**Qt Widgets与QML**

Qt Widgets 主要使用 C++ 代码，Qt Quick 主要使用 QML 和 JavaScript。

Qt Widgets适用于桌面开发，QML适用于移动端开发。



## 什么是Qt Quick?

Qt Quick is the standard library of types and functionality for QML. It includes visual types, interactive types, animations, models and views, particle effects and shader effects. A QML application developer can get access to all of that functionality with a single import statement.

Qt Quick是QML的一个标准库，提供QML的**类型和功能**（接口），`includes visual types, interactive types, animations, models and views, particle effects and shader effects`。

## Qt Quick类型

### 基础数据类型

color

font

matrix4x4

quaternion

### 对象类型

QtQuick导入提供的所有对象类型都基于Item类型，该类型本身派生自QtObject

有很多，可以产看Qt文档。



## Qt Quick的子模块







## *QML*类型——*Rectangle*

### 矩形元素的基本属性



**gradient**这个属性允许你定义矩形的渐变效果。

**anchors**：这个属性允许你定义矩形如何相对于其父元素或其他元素进行定位和大小调整。

```javascript
anchors具有多个属性，用于指定元素如何相对于其父元素或其他元素进行定位：

anchors.fill: 使元素填充其父元素。
anchors.left: 将元素的左边缘锚定到另一个元素或父元素的左边缘。
anchors.right: 将元素的右边缘锚定到另一个元素或父元素的右边缘。
anchors.top: 将元素的上边缘锚定到另一个元素或父元素的上边缘。
anchors.bottom: 将元素的下边缘锚定到另一个元素或父元素的下边缘。
anchors.horizontalCenter: 将元素的水平中心与另一个元素或父元素的水平中心对齐。
anchors.verticalCenter: 将元素的垂直中心与另一个元素或父元素的垂直中心对齐。
anchors.margins: 设置元素与其锚定边缘之间的边距。	
```



**border**：这个属性用于定义矩形的边框。它通常包含`color`、`width`和`radius`等子属性，用于定义边框的颜色、宽度和圆角半径。

**opacity**：这个属性定义了矩形的不透明度，范围为0（完全透明）到1（完全不透明）。





## Dialog 组件

**模态性（Modal）**：modal属性用于指定对话框是否为模态。**模态对话框会阻止用户与其他界面元素交互，直到对话框被关闭**。你可以将modal属性设置为true或false来启用或禁用模态性。



### 消息对话框：

```javascript
MessageDialog
            {
                id: messageDialog

                visible: false
                //Qt.WindowModal：非模态窗口。用户可以与其他窗口进行交互，而无需先关闭或接受该窗口。
                //Qt.NonModal：窗口模态。用户必须先与该窗口交互（例如，关闭它或点击其中的按钮），然后才能与其他属于同一父窗口或顶级窗口系统的窗口进行交互。
                modality:Qt.WindowModal
//                modality:Qt.NonModal
                title: "登录消息"
                text: "uesrname: " + username.text +"\n" + "password: " +password.text

                //系统提供的标准按钮
                standardButtons: StandardButton.Yes | StandardButton.YesToAll |
                         StandardButton.No | StandardButton.NoToAll | StandardButton.Abort
                //图标
                icon: StandardIcon.Information

                //补充信息
                informativeText:"12345678"

                //可隐藏的细节信息
                detailedText: "To replace a file means that its existing contents will be lost. " +
                         "The file that you are copying now will be copied over it instead."

                //信号
                onYes:console.log("yes")
                onNo: console.log("no")
                onAccepted:
                {
                    console.log("Save clicked")
                }

                onRejected:
                {
                    console.log("qwesss")
//                    close()
                    // 在这里处理拒绝的情况
                }

            }
```



### 文件对话框：

```javascript
```



### 目录文件对话框：

```javascript
```









## `QML`的`model-view`

​	模型存储数据，委托是如何设置显示数据，视图则是如何布局，绑定模型和委托去显示数据。

## ListModel 

`ListModel` 是一个简单的 **`ListElement`** 定义容器，每个定义都包含数据角色。内容可以动态定义，也可以在 QML 中显式定义。





## QML信号与槽

有内置的信号

自定义信号与槽：

```c++
signal mySigna(string message)
function onMySignal(message) {  
        console.log("Signal received: " + message)  
    }      

Item {  
    signal mySignal(string message)//自定义信号  
    function onMySignal(message) {//自定义槽函数  
        console.log("Signal received: " + message)  
    }  
    MouseArea {  
        anchors.fill: parent  
        onClicked: parent.mySignal("Button clicked!")  
    }  
    Connections {//连接  
        target: parent//发送信号的对象  
        onMySignal: onMySignal(message)//连接到槽函数  
    }  
}
```





QML与C++交互













Cmake
