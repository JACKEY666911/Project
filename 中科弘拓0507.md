中科弘拓

## 禅道系统：

### 是啥

领导分配需求和任务、计划工时，测试同学提出的BUG

我：填写实际开始时间、工作进度、日志、工时、任务状态

**注：若该任务无法在预估时长耗费完之前完成，项目组成员须提前一至三天向项目经理提出，由项目经理按项目管理规程执行相关变更流程**	

### 登录

重庆：http://192.168.0.211:9081/，企业版，用给的账号和密码

苏州办公或出差：

- 解压frp_0.45.0_windows_amd64，
- 进入相应文件夹，执行frpc.exe -c frpc.ini
- 打开浏览器，在地址栏访问http://127.0.0.1:9081/



## 出差相关：



重庆和苏州不算出差，只报销车费和住宿费，还有一次性补贴200

其他地方补贴：出差150元/天 



出差申请

钉钉：OA审批-办公常用-出差申请

飞机：填写航班号

时间：先填一个月，可修改时期

差旅申请审批通过后再购票





报销：



返程后，在DINGDING的OA系统办理差旅报销，**火车票、机票（行程单或电子发票需备注姓名和航班号等信息）、住宿费发票和市内交通费（如有）。**

发票信息：

企业名称:中科弘拓(苏州)智能科技有限公司

纳税人识别号:(统一社会信用代码) ：91320505MA7E5A6R62



个人报销支付时间：每月5号、15号、25号



## 考核：





## 系统开发部-部门职能

1.产品需求进行技术方案设计：包含概要设计和详细设计

2.根据方案进行资源申请：包括硬件、系统、服务器等

3.按照计划节点进行软件系统和硬件系统的开发

4.填写项目进度和执行情况报告

5.提交版本前，完成自测试：包括单元测试、集成测试、冒烟测试

6.



## 环境配置

### 远程访问重庆服务器：

1.开启远程访问

route -p add 192.168.0.0 mask 255.255.255.0 192.168.110.135

2.禅道地址

http://192.168.0.211:9081/

3.禅道账号

目前还未注册禅道账号

范诗杰的禅道账号fanshijie，fanshijie123 



### FTP（文件传输系统）：

FTP用户名：fanshijie，密码：fsj789，FTP地址：192.168.0.76，端口：21



### GitLab

范诗杰的gitlab账号fanshijie，fanshijie123

**范诗杰的gitlab账号fanshijie，369258Aa**

gitlab地址：http://192.168.0.211:8090/



1.配置

```bash
git config --global user.name "fanshijie" 
git config --global user.email "fanshijie@zkhongtuo.com"

ssh-keygen -t ed25519 -C "fanshijie@zkhongtuo.com"

cat ~/.ssh/id_ed25519.pub | clip
cat /c/Users/moliang/.ssh/id_ed25519.pub | clip



git remote add origin git@192.168.0.211:develop/training/fanshijie/face-sdk-video-client.git
```



2.拉代码，创建本地分支，关联远程分支

```bash

#先拉一版的代码
git clone URL
    
#创建本地分支，并切换到本地分支
git branch -b 本地分支名 

#关联到远程分支第一种方法
git branch -u origin/远程分支名  本地分支

git branch -u origin/远程分支名

#关联到远程分支第二种方法
git branch --set-upstream-to origin/远程分支名

#查看本地分支与远程分支的映射关系
git branch -vv



#删除本地分支
git branch -d 要删除的分支

#删除远程分支
git push origin -d [branch_name]
```



如何修改远程分支名字

```bash
#本地分支改名
git branch -m threadsSort feature/threadsSort
#删除远程分支
git push origin -d [branch_name]
#推送
git push origin feature/threadsSort
#追踪分支
git branch --set-upstream-to origin/feature/threadsSort


#本地分支改名
git branch -m threadsSort feature/threadsSort
#删除远程分支
git push origin -d [branch_name]
#推送并追踪
git push -u origin feature/threadsSort
```









3.GitLab流程

```bash
#1.查看已关联的远程仓库
git remote -v

#2.克隆远程仓库的项目代码
git clone "远程仓库地址"

#3.创建自己的本地分支
git branch -b 本地分支名

#4.在自己的分支 name中，此时可以进行相关代码开发

#5.提交代码
#（1）重新拉取 gitLab上的最新代码,合并到自己当前所在的分支
git pull -origin name//拉取name分支下的代码
#（2）查看当前修改或新增的文件
git status 
#（3）git三部曲
git add .
git commit - m "xxx"
git push --set-upstream origin 与本地分支名相同的分支名

#6.提交合并请求
git merge
```







### 邮箱

姓名：范诗杰 
手机号码： 
邮箱：fanshijie@zkhongtuo.com 
密码：8824lmzE9s 

密码：369258Aa

分组：系统研发部 
链接：https://qy.163.com/login/?from=ym





### visual studio 2017 安装基本使用

1.添加类时，Visual Studio 添加相应的 .h 和 .cpp 文件

2.**`#pragma once`** 行通知编译器仅包含一次头文件。

1.运行不调试

ctrl+f5



已完成

Qt5.12.12安装

进行中



## GitFlow流程

### 分支命名：

1.main分支：稳定的发布版本分支

2.develop分支：集成分支，用于功能集成

3.feature分支：用于功能开发。分支命名：feature/功能名

4.release分支：用于集成测试，QA测试。

5.BugFix分支：用于线上版本常规Bug修复，也可用于Release分支的的Bug修复。



### GitFlow工作流程：

1. develop分支以main分支为基础建立，

2. feature分支以develop分支为基础建立，用于某个功能的开发，进行代码编写，包含单元测试，本地冒烟测试等。

   注意：**每天下班前提交代码到分支。**

3. 功能开发完成后，合并到develop分支，这时候需要进行代码审查和合并，提交给有合并权限和审查权限的人。

   注意：**如果在合并过程中出现冲突，可以由开发人员来协助进行冲突解决，在进行合并。**

4. 合并完成后，以develop分支为基础建立release分支，开发人员进行集成测试，跑通所有的集成测试用例。开发人员在release分支上进行测试，并在此分支修改

5. 将release分支合并到main分支和develop分支上

6. main分支打包，然后在模拟环境进行测试，跑通用例，会单独拉一个BugFix分支分支进行Bug修复，修复完后合并到main分支和develop分支。

7. 正式发布，main分支打tag，删除release和feature分支







## 任务安排：

## 1.编写简单动态库

### 需求：

​	开发一个简单动态库，用C++类实现一个加法计算功能，可以直接返回计算结果或者通过回调函数返回计算结果，并提供C接口可以开启多个通道，每个通道有独立的加法计算类实例，确保每个通道是独立的并且相互不影响，需要使用CMake构建编译环境。能够同时在linux和windows平台编译

### 思路：

1.用c++实现加法计算功能

2.如何提供c接口

3.编写cmake文件，实现跨平台

4.编写app测试程序

5.在linux环境和visual studio下编译调试验证



![image-20240426150418473](C:\Users\JACK\AppData\Roaming\Typora\typora-user-images\image-20240426150418473.png)



**项目所在路径：E:\ProjectShare\MyAdd**



参考：

[cmake基础示例：如何编译【跨平台】的动态库和应用程序-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1926185)

[跨平台CMake判断当前平台是Linux还是Windows_cmake 判断平台-CSDN博客](https://blog.csdn.net/wu10188/article/details/124981846)

### 收获：

1.熟悉vs2017的cmake项目，可以参考

[visual studio的CMake 简易使用教程](https://www.bilibili.com/video/BV1us4y1J7HL?p=4&vd_source=e4a7cb76c28afe158431a92459d93e71)

2.VSCode 搭建多语言环境

[VSCode 搭建多语言环境](https://www.bilibili.com/video/BV1YL411L7Sg?p=6&vd_source=e4a7cb76c28afe158431a92459d93e71)



3.再次捡起了cmake的语法    针对动态库和嵌套`CmakeLists.txt`如何编写   以及cmake常见的系统变量

[CMake 保姆级教程（上） | 爱编程的大丙 (subingwen.cn)](https://subingwen.cn/cmake/CMake-primer/)     

[CMake 保姆级教程（下） | 爱编程的大丙 (subingwen.cn)](https://subingwen.cn/cmake/CMake-advanced/)

4.vs2017 自动补齐

![1714045625769](C:\Users\JACK\Documents\WeChat Files\wxid_mgop9apu4b6g22\FileStorage\Temp\1714045625769.png)



## 2.多线程

### 需求：

编写一个控制台程序，1、用std::condition_variable 实现的生产者,消费者同步的例子，生产线程产生1-10 10个数据，消费线程获取数据并打印结果。

2、用std::lock_guard实现多个线程访问同一个数值并对数值进行修改（增加/减少）操作并打印操作前数值、操作结果以及线程id，

3、设计一个多线程程序，用于下载多个文件。每个文件应该由一个单独的线程下载，并且要保证下载的并发性，需要使用libhttp库。

4、设计一个多线程程序，对一个大数组进行排序。要求使用多个线程并行处理数组的不同部分

### 思路：



### 收获

1.为什么pthread_cond_wait()需要传入一锁作为参数？

其一，在pthread_cond_wait()前，需要进行条件判断，*而此**条件**属于临界资源，需要在访问前加锁，此为保护临界资源的需要*。
其二，这也是面试官关注的，可以把问题转化为：为什么pthread_cond_wait()需要传入一锁作为参数？

当条件不满足时，pthread_cond_wait()内部将执行两个步骤，并保证两个操作的原子性：
1.将当前线程加入条件信号的等待队列。
2.解作为参数传入的锁，解除对临界资源的锁定。



```c++
lock();
while(条件不满足)
{
	unlock();//#1:解除对临界资源的锁定。
	pthread_cond_wait(condA);//#2:当前线程加入等待队列，阻塞
	lock();//#3:再次判断之前，对临界资源保护
}
doSomething();
unlock();
```

#1和#2之间非原子操作，中间有间隙。间隙中间，如果有线程发送signal了，这时候condA还未未加入等待队列，会造成错过通知，一直阻塞。

为保证“解锁”和“加入等待队列”两操作的原子性，从而避免可能发生的死锁。



2.`std::mutex`的理解和使用

Mutex有4类：

- std::mutex，最基本的 Mutex 类。

- std::recursive_mutex，递归 Mutex 类。
- std::time_mutex，定时 Mutex 类。
- std::recursive_timed_mutex，定时递归 Mutex 类。

Lock类：

std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。

std::unique_lock，提供了更好的上锁和解锁控制，可以手动解锁	



3.\#include <thread>常用函数

```c++
//获取当前线程的ID。
std::this_thread::get_id();

//检查线程是否可以被join。
joinable()//缺省构造的thread对象、已经完成join的thread对象、已经detach的thread对象都不是joinable。
    
//等待线程完成执行。调用该函数的线程（主调线程）会被阻塞，直到被join的线程执行结束。
join()
    
//将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。
detach()
    
//定时功能,休眠
std::this_thread::sleep_for(std::chrono::seconds(1));
```





## 3.Qt程序

### 需求：

编写一个控制台程序，1、设计一个多线程的 Qt 程序，用于下载多个文件。每个文件应该由一个单独的线程下载，并且要保证下载的并发性。

2、设计一个生产者-消费者模型的 Qt 程序，其中生产者生产数据并将其放入有限大小的缓冲区，消费者从缓冲区中取出数据并消费。

3、设计一个 Qt 程序，对一个大数组进行排序。要求使用多个线程并行处理数组的不同部分。

4、设计一个线程池的 Qt 程序，它可以管理一组预先创建的线程，当有任务需要执行时，从线程池中取出一个线程执行任务

### 思路：



### 收获:、

`QObject`是Qt框架的基本类，但凡涉及到信号槽有关的类都是继承于`QObject`。

QThread总结和注意事项

1.Qt中实现多线程的两种方式

继承`QThread`，实现`run`方法，可以在run方法中开启事件循环（默认没开启事件循环，run执行完返回后线程结束）。值得注意的是，只有run（）函数内部是在新线程中运行，其他的槽函数是在`QThread`所依附的对象中调用。

使用QObject的线程转移函数，`void moveToThread(QThread * targetThread)`，可以把一个**顶层Object（就是没有父级）**转移到一个新的线程里。



2.Qt线程的退出和资源释放问题



3.Qt线程的注意事项



## 4.Qt界面演示

编写一个简单的Qt界面演示程序，

1、设计一个简单的登录界面，包括用户名和密码的输入框，以及登录按钮，点击登录按钮后弹出消息框显示输入的数据。

已完成

2、设计一个文件浏览器界面，显示当前目录下的文件和子目录。

关键点：

1.模型/视图构架
2.自定义模型类
3.QML与C++交互
4.QML中信号与槽
5.Qt当中读写文件
6.Qt当中遍历文件夹



思路：先定义一个模型类，存储本地文件夹 的文件信息。将得到的模型绑定到ListView并自定义一个委托去显示。

模型存储数据，委托是如何设置显示数据，视图则是如何布局，绑定模型和委托去显示数据。

```javascript
    ListView {
        id: view

        anchors { fill: parent; margins: 2 }

        model: PetsModel {}//模型
        delegate: dragDelegate//代理

        spacing: 4
        cacheBuffer: 50
    }
```





View:`QML`当中提供了`ListView`,`TreeView`,`TableView`这三个视图



3、设计一个简单的图像查看器，能够显示和缩放图像。







# Qt的`http`网络编程

### QNetworkRequest

`QNetworkRequest` 是 Qt 框架中用于封装 HTTP 或其他网络请求信息的类。它包含了 URL、HTTP 头部（headers）、SSL 配置等信息，这些信息会被 `QNetworkAccessManager` 使用来执行实际的网络请求。

**设置请求URL**：通过`setUrl()`函数设置请求的URL地址，支持HTTP和HTTPS协议。

```c++
QNetworkRequest request;  
QUrl url("http://example.com");  
request.setUrl(url);
```



### QNetworkAccessManager

`QNetworkAccessManager`类管理网络请求，并提供一个异步的`API`来发送网络请求并接收响应。这个类通常用于创建和管理网络请求。

```c++
    mNetworkManager = new QNetworkAccessManager(this);
    QNetworkRequest _quest;
    QString url = "http://127.0.0.1:8083/v3/api/client/v1/captchaImage";
    url.append("?key1=小强&key2=xiao qing");
    _quest.setUrl((QUrl(url)));
    _quest.setHeader(QNetworkRequest::ContentTypeHeader,"application/x-www-form-urlencoded");
	//使用get方法发送网络请求
    mReply = mNetworkManager->get(_quest);
    QByteArray _data = mReply->readAll();//读出数据
    //QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss.zzz").toUtf8().constData();
    qInfo()<<"1_data ==> "<<_data;
    //connect(mReply,&QNetworkReply::finished,this,&HttpOperate::ReplyFinshed);//方式一
    // auto lambdaFun = [=]{ReplyFinshed();};//lambda函数
    // connect(mReply,&QNetworkReply::finished,lambdaFun);//这里的信号的接受者可以省略不写
    connect(mReply,&QNetworkReply::finished,[=]{//这里的信号的接受者可以省略不写
        ReplyFinshed();
    });
```







### Get请求步骤

步骤：

1. 初始化QNetworkAccessManager对象。
2. 设置请求URL。
3. 连接消息返回。
4. 发送GET请求。



### Post请求步骤

初始化QNetworkAccessManager对象。
设置请求URL。
设置请求头Header
设置请求主体
连接消息返回。
发送POST请求。





Get方法下载文件

1. **创建`QNetworkAccessManager`实例**：`QNetworkAccessManager`是Qt网络编程的核心类，用于发送网络请求并接收响应。
2. **发送HTTP GET请求**：使用`QNetworkAccessManager`的`get()`方法发送GET请求到指定的URL。
3. **连接信号和槽**：连接`QNetworkReply`的`finished()`信号到一个槽函数，以便在请求完成时处理响应。
4. **读取响应数据**：在槽函数中，使用`QNetworkReply`的`readAll()`方法读取响应数据。
5. **保存文件**：将读取到的数据写入文件。
6. **清理资源**：删除`QNetworkReply`对象，以释放资源。







# Vs code 项目执行





## 为 Microsoft C++ 配置 VS Code

### [先决条件](https://code.visualstudio.com/docs/cpp/config-msvc#_prerequisites)

1.c/c++拓展

2.安装 Microsoft Visual C++ （MSVC） 编译器工具集。

### [创建 Hello World 应用](https://code.visualstudio.com/docs/cpp/config-mingw#_create-a-hello-world-app)

- `tasks.json`（构建说明）`Ctrl+Shift+P` -> `Tasks: Configure Tasks`
- `launch.json`（调试器设置）

​	问：怎么产生和配置`c_cpp_properties.json`

​	![image-20240511162948584](C:\Users\moliang\AppData\Roaming\Typora\typora-user-images\image-20240511162948584.png)

- **`c_cpp_properties.json`**（编译器路径和` IntelliSense` 设置）:这个文件对于 `IntelliSense`（`VSCode` 中的代码智能感知功能）特别重要，因为它帮助 `IntelliSense` 理解你的项目结构和代码.

  - **编译器路径**: 指定用于解析代码的编译器路径。
  - **包含路径**: 指定项目中使用的头文件所在的目录。可以在源文件跳转到包含的位置查看定义
  - **定义**: 可以定义预处理器宏。
  - **编译命令**: 可以指定完整的编译命令，以便从构建系统中获取更多信息。

  ​	问：怎么产生`c_cpp_properties.json`

  ​	`ctrl+shift+P`->`C/C++`

  ​	问：啥是`IntelliSense`

  ​	`IntelliSense` 是各种代码编辑功能的总称，包括：代码完成、参数信息、快速信息和成员列表。

​	

## [创建 CMake项目](https://code.visualstudio.com/docs/cpp/CMake-linux#_create-a-cmake-hello-world-project)

### [选择套件](https://code.visualstudio.com/docs/cpp/CMake-linux#_select-a-kit)

在使用 CMake Tools 扩展生成项目之前，需要对其进行配置以了解系统上的编译器。通过扫描“套件”来做到这一点。工具包表示工具链，工具链是用于构建项目的编译器、链接器和其他工具。要扫描试剂盒：

1. 打开命令面板 （Ctrl+Shift+P） 并运行 **CMake： Select a Kit**。该扩展将自动扫描您计算机上的工具包，并创建在您的系统上找到的编译器列表。
2. 选择要使用的编译器。
3. 更改套件，您可以在 CMake 工具边栏的**“项目状态**”视图中单击套件，或从命令面板中再次运行 **CMake： Select a Kit** 命令。如果您没有看到要查找的编译器，则可以在项目中编辑该文件。若要编辑文件，请打开命令面板 （Ctrl+Shift+P） 并运行**“CMake：编辑用户本地 CMake Kits**”命令。`cmake-tools-kits.json`

### [选择款式/规格](https://code.visualstudio.com/docs/cpp/CMake-linux#_select-a-variant)

变体包含有关如何生成项目的说明。默认情况下，CMake Tools 扩展提供四个变体，每个变体对应于默认生成类型：、、 和 。这些选项执行以下操作：`Debug``Release``MinRelSize``RelWithDebInfo`

若要选择变体，请打开命令面板 （Ctrl+Shift+P） 运行**“CMake： Select Variant**”命令。

### [CMake：配置](https://code.visualstudio.com/docs/cpp/CMake-linux#_cmake-configure)

选择工具包和变体后，请打开命令面板 （Ctrl+Shift+P） 并运行 **CMake： Configure** 命令来配置项目。这将使用您选择的套件和变体在项目的构建文件夹中生成构建文件。

### [构建 hello world](https://code.visualstudio.com/docs/cpp/CMake-linux#_build-hello-world)

配置项目后，即可进行构建。打开命令面板 （Ctrl+Shift+P） 并运行 **CMake： Build** 命令，或从状态栏中选择**“生成**”按钮。



### [调试 hello world](https://code.visualstudio.com/docs/cpp/CMake-linux#_debug-hello-world)

若要运行和调试项目，请打开并在行上放置断点。 然后打开命令面板 （Ctrl+Shift+P） 并运行 **CMake： Debug**。调试器将停止在线：`main.cpp``std::cout``std::cout`

调试器：GDB	LLDB公司    MSVC公司

继续并按 F5 继续。





# CMake
